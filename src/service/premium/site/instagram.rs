use std::{collections::HashSet, time::Duration};

use chrono::{DateTime, Utc};
use rss::{Channel, ChannelBuilder, Image, Item, ItemBuilder};
use sqlx::MySqlPool;
use thirtyfour::{error::WebDriverError, By, WebDriver};
use tokio::time::sleep;

use crate::{
    config::webdriver::{AcquireStrategy, DriverHandle, DriverPool},
    model::error::OmniNewsError,
    service::{
        channel_service::{self},
        item_service::{self},
    },
    utils::embedding_util::EmbeddingService, // channel_service 등 저장 로직 필요시 import
                                             // service::channel_service,
};

/// 인스타그램 프로필로부터 RSS 채널 생성 (게시물 12개 수집)
pub async fn generate_rss(
    pool: &MySqlPool,
    embedding_service: &EmbeddingService,
    driver_pool: &DriverPool,
    link: &str,
) -> Result<i32, OmniNewsError> {
    // acquire driver
    let strategy = AcquireStrategy::Wait(Some(Duration::from_secs(10)));
    let driver_handle = driver_pool.acquire(strategy).await.map_err(|e| {
        error!("[Service-instagram] Failed to acquire WebDriver: {:?}", e);
        OmniNewsError::WebDriverPool(e)
    })?;
    let driver = driver_handle.driver();

    let (username, rss_channel, channel_id) =
        generate_rss_channel(pool, embedding_service, link, driver).await?;

    let pool_cl = pool.clone();
    let emb_cl = embedding_service.clone();
    // rss item parsing은 시간이 걸림으로 쓰레드로 처리
    // pool, embedding은 clone, webdriver는 handle 소유권을 넘겨 drop되지 않도록 함.
    tokio::spawn(async move {
        match generate_rss_item(
            &pool_cl,
            &emb_cl,
            &username,
            driver_handle,
            rss_channel,
            channel_id,
        )
        .await
        {
            Ok(_) => {
                info!("[Instagram] Successfully generated RSS for {username}.");
            }
            Err(e) => {
                error!("[Instagram] Failed to generate RSS items: {e}");
            }
        }
    });

    Ok(channel_id)
}

async fn generate_rss_channel(
    pool: &sqlx::Pool<sqlx::MySql>,
    embedding_service: &EmbeddingService,
    link: &str,
    driver: &WebDriver,
) -> Result<(String, Channel, i32), OmniNewsError> {
    let username = extract_username(link).ok_or_else(|| OmniNewsError::ExtractLinkError)?;
    driver
        .goto(format!("https://www.instagram.com/{}/", username))
        .await
        .map_err(map_wd_err)?;
    sleep(Duration::from_secs(4)).await;
    if is_login_page(driver).await? {
        attempt_login(driver).await?;
        wait_until_profile_loaded(driver).await?;
    } else {
        // 혹시 로그인 유도 모달(닫기 버튼) 존재시 닫기 (한국어/영어 모두 대응)
        dismiss_close_overlay(driver).await.ok();
    }
    let (channel_title, channel_description, channel_image_url) =
        extract_profile_meta(driver).await?;
    let mut image = Image::default();
    image.set_url(channel_image_url.clone());
    image.set_title(channel_title.clone());
    image.set_description(Some(channel_description.clone()));
    let rss_channel: Channel = ChannelBuilder::default()
        .title(channel_title.clone())
        .description(channel_description)
        .link(link.to_string())
        .image(image)
        .generator("instagram".to_string())
        .build();
    let channel = channel_service::make_rss_channel(
        &rss_channel,
        format!("Generated by Omninews, {}", channel_title),
        true,
    );
    let channel_id =
        channel_service::store_channel_and_embedding(pool, embedding_service, channel).await?;
    Ok((username, rss_channel, channel_id))
}

async fn generate_rss_item(
    pool: &sqlx::Pool<sqlx::MySql>,
    embedding_service: &EmbeddingService,
    username: &str,
    driver_handle: DriverHandle,
    mut rss_channel: Channel,
    channel_id: i32,
) -> Result<(), OmniNewsError> {
    let driver = driver_handle.driver();
    let post_links = collect_post_links(driver, 12).await?;
    let mut items: (Vec<Item>, Vec<String>) = (Vec::new(), Vec::new());
    for href in post_links {
        match parse_post_page(driver, &href, username).await {
            Ok((item, image_link)) => {
                items.0.push(item);
                items.1.push(image_link)
            }
            Err(e) => {
                error!("[Instagram] Failed to parse post ({href}): {e}");
                continue;
            }
        }
        if items.0.len() >= 12 {
            break;
        }
    }
    if items.0.is_empty() {
        return Err(OmniNewsError::NotFound(
            "No Instagram posts could be parsed.".into(),
        ));
    }
    rss_channel.set_items(items.0.clone());
    let _ = item_service::crate_rss_items_and_embedding(
        pool,
        embedding_service,
        rss_channel,
        Some(items.1),
        channel_id,
    )
    .await
    .map_err(|e| {
        error!(
            "[Service-instagram] Failed to create rss item and embedding: {:?}",
            e
        );
        e
    });
    Ok(())
}

/* ---------------- Helper Functions ---------------- */

fn extract_username(link: &str) -> Option<String> {
    // https://www.instagram.com/{username}/
    let trimmed = link.trim_end_matches('/');
    trimmed.rsplit('/').next().map(|s| s.to_string())
}

async fn is_login_page(driver: &WebDriver) -> Result<bool, OmniNewsError> {
    Ok(driver.find(By::Name("username")).await.is_ok()
        && driver.find(By::Name("password")).await.is_ok())
}

async fn attempt_login(driver: &WebDriver) -> Result<(), OmniNewsError> {
    let username = "omninews1027@gmail.com";
    let password = "Kk2167512##";

    info!("[Instagram] Attempting login...");

    let user_field = driver
        .find(By::Name("username"))
        .await
        .map_err(map_wd_err)?;
    let pass_field = driver
        .find(By::Name("password"))
        .await
        .map_err(map_wd_err)?;

    user_field.send_keys(username).await.map_err(map_wd_err)?;
    pass_field.send_keys(password).await.map_err(map_wd_err)?;

    sleep(Duration::from_millis(600)).await;
    if let Ok(btn) = driver.find(By::XPath("//button[@type='submit']")).await {
        btn.click().await.map_err(map_wd_err)?;
    }

    // save login info window
    sleep(Duration::from_millis(7000)).await;
    if let Ok(btn) = driver
        .find(By::XPath(
            "//button[text()='정보 저장'] | //button[text()='Save info']",
        ))
        .await
    {
        btn.click().await.map_err(map_wd_err)?;
        info!("[Instagram] Saved login info.");
    } else {
        info!("[Instagram] No save login info button found.");
    }

    // 로그인 처리 대기 (최대 30초)
    for _ in 0..10 {
        if !is_login_page(driver).await? {
            info!("[Instagram] Login success (username/password gone).");
            return Ok(());
        }
        info!("[Instagram] Waiting for login...");
        sleep(Duration::from_secs(3)).await;
    }

    error!("[Service-Instagram] Login failed or timed out.");
    Err(OmniNewsError::WebDriverNotFound)
}

async fn wait_until_profile_loaded(driver: &WebDriver) -> Result<(), OmniNewsError> {
    // username 포함하는 /{username}/ 링크나 post anchor 존재 여부로 판단
    for _ in 0..10 {
        if driver
            .find(By::XPath("//a[contains(@href,'/p/')]"))
            .await
            .is_ok()
        {
            return Ok(());
        }
        // 혹시 로그인 유지 모달 닫기 등
        dismiss_close_overlay(driver).await.ok();
        sleep(Duration::from_secs(2)).await;
    }
    Err(OmniNewsError::WebDriverNotFound)
}

// TODO: 동작 안함.
async fn dismiss_close_overlay(driver: &WebDriver) -> Result<(), OmniNewsError> {
    // 한국어 title='닫기', 영어 title='Close'
    if let Ok(close_div) = driver
        .find(By::XPath(
            "//div[.//svg/title[text()='닫기' or text()='Close']]",
        ))
        .await
    {
        close_div.click().await.map_err(map_wd_err)?;
        sleep(Duration::from_millis(400)).await;
        info!("[Instagram] Closed overlay (Close/닫기).");
    }
    Ok(())
}

async fn extract_profile_meta(
    driver: &WebDriver,
) -> Result<(String, String, String), OmniNewsError> {
    // meta og:title, og:description, og:image
    let title = get_meta_content(driver, "og:title").await?;
    let desc = get_meta_content(driver, "og:description")
        .await
        .unwrap_or_else(|_| "".into());
    let img = get_meta_content(driver, "og:image")
        .await
        .unwrap_or_default();

    Ok((title, desc, img))
}

async fn get_meta_content(driver: &WebDriver, property: &str) -> Result<String, OmniNewsError> {
    let selector = format!("meta[property='{property}']");
    let el = driver.find(By::Css(&selector)).await.map_err(map_wd_err)?;
    let content = el
        .attr("content")
        .await
        .map_err(map_wd_err)?
        .unwrap_or_default();
    Ok(content)
}

async fn collect_post_links(
    driver: &WebDriver,
    target: usize,
) -> Result<Vec<String>, OmniNewsError> {
    let mut links: HashSet<String> = HashSet::new();
    let mut scroll_attempts = 0;
    let max_scroll_attempts = 15;

    loop {
        // 현재 DOM에서 링크 추출 (href 패턴 기반)
        let anchors = driver
            .find_all(By::XPath(
                "//a[contains(@href,'/p/') or contains(@href,'/reel/')]",
            ))
            .await
            .unwrap_or_default();

        for a in anchors {
            if let Ok(Some(href)) = a.attr("href").await {
                // 상대경로 -> 절대경로
                if href.contains("/p/") || href.contains("/reel/") {
                    let full = if href.starts_with("http") {
                        info!("href: {href}");
                        href
                    } else {
                        format!("https://www.instagram.com{href}")
                    };
                    links.insert(full);
                }
            }
            if links.len() >= target {
                break;
            }
        }

        if links.len() >= target {
            break;
        }

        // 스크롤
        let _ = driver
            .execute(
                "window.scrollTo(0, document.body.scrollHeight); return document.body.scrollHeight;",
                vec![],
            )
            .await;
        sleep(Duration::from_secs(2)).await;

        scroll_attempts += 1;
        if scroll_attempts >= max_scroll_attempts {
            info!(
                "[Instagram] Reached max scroll attempts. Collected {} posts.",
                links.len()
            );
            break;
        }
    }

    if links.is_empty() {
        return Err(OmniNewsError::NotFound(
            "No post links found on profile.".into(),
        ));
    }

    let mut collected: Vec<String> = links.into_iter().collect();
    collected.sort();
    Ok(collected.into_iter().take(target).collect())
}

async fn parse_post_page(
    driver: &WebDriver,
    url: &str,
    username: &str,
) -> Result<(Item, String), OmniNewsError> {
    // 새 탭 열기
    driver
        .execute(&format!("window.open('{}','_blank');", url), vec![])
        .await
        .map_err(map_wd_err)?;

    // 윈도우 전환
    let handles = driver.windows().await.map_err(map_wd_err)?;
    let new_handle = handles.last().ok_or_else(|| {
        OmniNewsError::NotFound("No new window handle after opening post.".into())
    })?;
    driver
        .switch_to_window(new_handle.clone())
        .await
        .map_err(map_wd_err)?;
    sleep(Duration::from_secs(3)).await; // 로딩 대기

    // 메타 정보 수집
    let og_title = get_meta_content(driver, "og:title")
        .await
        .unwrap_or_default();
    let og_desc = get_meta_content(driver, "og:description")
        .await
        .unwrap_or_default();
    let og_image = get_meta_content(driver, "og:image")
        .await
        .unwrap_or_default();

    // time 태그
    let pub_date_raw = if let Ok(time_el) = driver.find(By::Css("time")).await {
        time_el
            .attr("datetime")
            .await
            .map_err(map_wd_err)?
            .unwrap_or_default()
    } else {
        "".into()
    };

    // datetime -> RFC 2822 (rss pubDate) 변환 시도
    let pub_date_rfc2822 = if !pub_date_raw.is_empty() {
        // Instagram time: ISO8601 (e.g. 2025-08-12T09:00:00.000Z)
        match DateTime::parse_from_rfc3339(&pub_date_raw) {
            Ok(dt) => dt.to_rfc2822(),
            Err(_) => {
                // fallback: try Utc parse
                if let Ok(dt2) = DateTime::parse_from_rfc3339(&(pub_date_raw.clone() + "Z")) {
                    dt2.to_rfc2822()
                } else {
                    // final fallback: now
                    Utc::now().to_rfc2822()
                }
            }
        }
    } else {
        Utc::now().to_rfc2822()
    };

    // title / description 정리
    // og:title 종종 "username on Instagram: “본문 일부…”" 형태
    let (title, description) = refine_text(&og_title, &og_desc);

    let item = ItemBuilder::default()
        .title(title)
        .description(description)
        .link(url.to_string())
        .author(username.to_string())
        .pub_date(pub_date_rfc2822)
        .enclosure({
            // 이미지가 있다면 enclosure 로 넣을 수도 있음 (선택)
            // rss::extension::dublincore 나 custom 사용 가능. 여기서는 skip 또는 image URL logging
            None
        })
        .build();

    // 탭 닫고 원래 핸들 복귀
    driver.close_window().await.map_err(map_wd_err)?;
    let handles_after = driver.windows().await.map_err(map_wd_err)?;
    if let Some(original) = handles_after.first() {
        driver
            .switch_to_window(original.clone())
            .await
            .map_err(map_wd_err)?;
    }

    Ok((item, og_image))
}

fn refine_text(og_title: &str, og_desc: &str) -> (String, String) {
    // 단순 정제 로직 (원하는 형태로 커스터마이징 가능)
    // TODO: title이랑 desciprion이랑 같은 경우가 있음. 어떻게 정제할지 생각해보기
    let title_candidate = og_title.trim();
    // og:description 은 종종 "Instagram: ..." 형태 / 게시물 내용 + " • Instagram" 등
    let mut desc_candidate = og_desc.trim().to_string();
    if let Some(pos) = desc_candidate.rfind("Instagram") {
        // 너무 뒤쪽 마무리 제거 시도
        if pos > 40 {
            // 내용이 충분히 긴 경우만 자름
            desc_candidate = desc_candidate[..pos].trim().to_string();
        }
    }

    // 너무 짧으면 타이틀/디스크립션 서로 fallback
    let title = if title_candidate.is_empty() {
        desc_candidate.chars().take(60).collect()
    } else {
        title_candidate.to_string()
    };

    let desc = if desc_candidate.is_empty() {
        title.clone()
    } else {
        desc_candidate
    };

    (title, desc)
}

fn map_wd_err(e: WebDriverError) -> OmniNewsError {
    OmniNewsError::WebDriverError(e)
}
